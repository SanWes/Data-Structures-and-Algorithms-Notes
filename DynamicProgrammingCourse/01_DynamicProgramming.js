
/* Dynamic Programming - Learn to Solve Algorithmic Problems & Coding Challenges
     https://www.youtube.com/watch?v=oBt53YbR9Kk&t=1922s&ab_channel=freeCodeCamp.org

    Memoization - Memoization is a data structure that can be used to store the results of a computation that has already been done. It can be used to improve the performance of a computation by storing the results of the previous computation in a cache.  

    Fibonnaci Sequence - Fibonacci Sequence is a sequence of numbers that is generated by adding the previous number and the current number. 

    Adding key and value to dictonary to store the results of a computation. 

 */

    // optimized fib sequence cuts down amount of recursive calls 

    // Utilize memoization, set default to an empty object. We will pass along results from the recursion as we go along. 

    const fib = (n, memo = {}) => { 

        // initial check if n is in memo to save time repeating fib trees
        if (n in memo) return memo[n];

        // Create a base case to end the recursion
        if (n<= 2) return 1;

        // recursion n-1 + n-2
        memo[n] = fib(n - 1, memo) + fib(n-2, memo);
        return memo[n];
    }

    // Demo fib(6)
    // O(n) Space Complexity 
    // O(n) Time Complexity

    /*
    fib(6) = 8
    memo 
    {
        3: 2,
        4: 3,
        5: 5,
        6: 8,
    }


    Bio O Notation 

    Time complexity O(n)
    Space complexity O(n)
    By memoizing the fib algo we Optimized solution from exponential to linear time complexity 




        write a function gridTraveler(m,n)




*/
    // m = rows  n = columns 
const gridTraveler = (m, n) =>  {
    // Base Cases - 1x1 Grid and invalid grid
    if (m === 1 && n === 1 ) return 1;
    if (m === 0 && n === 0 ) return 0;

    // Recursive: sum of going downward and rightward
    return gridTraveler(m - 1, n) + gridTraveler(m, n - 1);

}

/*
console.log(gridTraveler(1, 1 )); // 1
console.log(gridTraveler(2, 3 )); // 3
console.log(gridTraveler(3, 2 )); // 3
console.log(gridTraveler(3, 3)); // 6
console.log(gridTraveler(18, 18 )); // 2333606220
// console.log(gridTraveler(1, 1 ));

*/

/*

This Recursion is slow when it comes to 18x18 grid, This is a brute force approach. 


Bio O Notation 

    Time complexity Exponential
    O(2 ^ n+m) Time 
    Space complexity O(n + m)
    Height of the Tree = O(n + m) space

    Search for duplicates in the tree as you recursively progress through each option of the grid. 

    gridTraveler(2,3)

    Lets memoize the solution 





*/



// Memoize GridTrav

const memoizedGridTraveler = (m, n, memo = {}) =>  {
    // create separator to identify each grid in memo ',' 
    let key = m + ',' + n;
    // are the arguments in the memo? 
    if (key in memo) return memo[key];
    

    // Base Cases - 1x1 Grid and invalid grid
    if (m === 1 && n === 1 ) return 1;
    if (m === 0 || n === 0 ) return 0;

    // Recursive: sum of going downward and rightward
    memo[key] = memoizedGridTraveler(m - 1, n, memo) + memoizedGridTraveler(m, n - 1, memo);

    return memo[key];

}

// console.log("TESTING");
// console.log(memoizedGridTraveler(1, 1 )); // 1
// console.log(memoizedGridTraveler(2, 3 )); // 3
// console.log(memoizedGridTraveler(3, 2 )); // 3
// console.log(memoizedGridTraveler(3, 3)); // 6
// console.log(memoizedGridTraveler(18, 18 )); // 2333606220


/* 

    m choices for the 1st # in the node and n in the 2nd. 
    so m * n possible combinations 

    m: { 0, 1, 2, 3, 4 }
    n: { 0, 1, 2, 3 }

Bio O Notation 

    Time complexity improved from exponential to:
    O(m * n) Time 

    Space complexity remains the same at multi linear function: 
    O(n + m)

*/





/* 


                    Memoization RECIPE

        1. Make it work [BRUTE FORCE APPROACH] : 
            - Visualize the problem as a tree 
            - implement the tree using recursion
            - test a base case to end the recursion with Brute Force approach

        2. Make it efficient
            - add a memo object with a default value at the top call
            - add a base case to return memo values 
            - store retrun values into the memo 






            New Memoization Problem: 

            Write a function 'canSum(targetSum, numbers)' :
            Should return a boolean indicating wether or not it is possible to generate the target sum using numbers from the array. 


            example: 
            #1
            canSum(7, [5, 3, 4, 7]) -> true 
            #2
            canSum(7, [2, 3]) -> false


            #2: an option for each option in the array. Consider the problem as a tree. visualize the nodes out to the leaf level. 

            Nodes with 0 will be considered as base case and return true back to parent. 
            If any of the nodes has a value greater than 0, and cannot be broken down further, will return false. 

            ***BOOLEAN KEY ****
            If at least one of the children node is true, it will return true. and continue to buble up to the top of tree evaluating it


            */


const canSum = (targetSum, numbers) => {
    if (targetSum === 0) return true;
    if (targetSum < 0) return false;

    for (let num of numbers) {
        const remainder = targetSum - num;
        // sometimes it may become be negative lets add base case

        if ( canSum( remainder, numbers ) === true ) {
        return true;
        }
    }
    // want to return false outside of the for loop. 
    return false;
}

/*

TESTING canSum

console.log(canSum(7, [2,3])); // true 
console.log(canSum(7, [5,3,4,7])); // true
console.log(canSum(7, [2,4])); // false
console.log(canSum(7, [2,3,5])); // true
console.log(canSum(300, [7, 14])); // false This solution takes a long run time. 

*/



/*
 Bookmark 1:23:00 @ Video


m = target sum
n = array length 


root to the base case would be m . height of tree. 

How does # of nodes change from one to the next. 

in this case *n


O(n^m) time 
O(m) space 



Lets Memoize it!!

  Memoization RECIPE

        1. Make it work [BRUTE FORCE APPROACH] : 
            - Visualize the problem as a tree 
            - implement the tree using recursion
            - test a base case to end the recursion with Brute Force approach

        2. Make it efficient
            - add a memo object with a default value at the top call
            - add a base case to return memo values 
            - store retrun values into the memo 



*/





const memoizeCanSum = (targetSum, numbers, memo={}) => {
    if (targetSum in memo) return memo[targetSum];
    if (targetSum === 0) return true;
    if (targetSum < 0) return false;

    for (let num of numbers) {
        const remainder = targetSum - num;

        if ( memoizeCanSum( remainder, numbers , memo) === true ) {
        memo[targetSum] = true;
        return true;
        }
    }
    //
    memo[targetSum] = false;
    return false;
}

/*

            Testing Memoized Solution  
console.log(memoizeCanSum(7, [2,3])); // true 
console.log(memoizeCanSum(7, [5,3,4,7])); // true
console.log(memoizeCanSum(7, [2,4])); // false
console.log(memoizeCanSum(7, [2,3,5])); // true
console.log("HOW FAST>>",memoizeCanSum(300, [7, 14])); // false This solution is much faster now that we memoized it





    New Problem 

    Write function 'howSum(targetSum, numbers)' 
    Return an array of any combination of elements that add up to the targetSum. 
    If not available, return null. 

    If there are multiple combos possible, return any ONE of them.

    howSum(7, [5,3, 4, 7 ]) -> [7]
    howSum(7, [5,3, 4, 7 ]) -> [3, 4]
    howSum(8, [2, 3, 5 ]) -> [2, 2, 2, 2]
    howSum(8, [2, 3, 5 ]) -> [3, 5]
    howSum(7, [2, 4 ]) ->  null
    howSum(0, [1, 2, 3 ]) -> []



    Similar to prev, except it is not a boolean return this time. 

    

    if at least one of the branches is !null then over rides and becomes that [n]


*/


const howSum = (targetSum, numbers) => {
    if(targetSum === 0 ) return [];
    if (targetSum < 0 ) return null;

    for (let num of numbers) {
        const remainder = targetSum - num;
        const remainderResult = howSum(remainder, numbers);
        if (remainderResult !== null) {
            return [...remainderResult, num];
        }
    }


    return null;
};


console.log(howSum(7, [2,3]));  // [3, 2, 2]
console.log(howSum(7, [5,3,4,7])); // [4, 3]
console.log(howSum(7, [2,4])); // null
console.log(howSum(8, [2,3,5])); // [2, 2,2,2]
console.log(howSum(300, [7,14])); // null -> Slow Response 


/*

Time Complexity 
m = target sum 
n= numbers.length 


Brute Force Approach 
time : O(n^m * m)
space: O(m)



    Time to Memoize and optimize solution


*/




const memoizeHowSum = (targetSum, numbers, memo = {}) => {
    if (targetSum in memo) return memo[ targetSum];

    if(targetSum === 0 ) return [];
    if (targetSum < 0 ) return null;

    for (let num of numbers) {
        const remainder = targetSum - num;
        const remainderResult = memoizeHowSum(remainder, numbers, memo);
        if (remainderResult !== null) {
            memo[targetSum] = [...remainderResult, num];
            return memo[targetSum] ;
        }
}

    memo[targetSum] = null
    return null;
};

console.log("MEMOIZED HOW SUM : ");
console.log(memoizeHowSum(7, [2,3]));  // [3, 2, 2]
console.log(memoizeHowSum(7, [5,3,4,7])); // [4, 3]
console.log(memoizeHowSum(7, [2,4])); // null
console.log(memoizeHowSum(8, [2,3,5])); // [2, 2,2,2]
console.log(memoizeHowSum(300, [7,14]), "MEMOIZE FOR FASTER RESPONSE" ); // null -> MUCH FASTER Response 


/*

Time Complexity 
m = target sum 
n= numbers.length 


Brute Force Approach 
time : O(n^m * m)
space: O(m)

Memoized Approach
time: O(n * m^2)
space: O(m*m) 


*/


/*
DYNAMINC PROGRAMMING 

canSum -> Decision Problem

howSum -> Combinatoric Problem

bestSum -> Optimization Problem






Lets try to solve the problem with memoization.
1. add memo object to the function
2. add if statement to check if target is in memo object. If it is then return memo[target].
3. Pass down memo to recursive calls 
4. Store data in memo object. Where there are recursive return. Now store that return value in memo before you complete the return. 













*/